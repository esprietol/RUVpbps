---
title: "ruvPBPS"
output: rmarkdown::html_vignette
bibliography: ref.bib
vignette: >
  %\VignetteIndexEntry{ruvPBPS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE,message=FALSE,warning=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}

library(RUVpbps)
library(edgeR)
library(scater)
library(tidyr)
library(dplyr)


```

# Overview

External factors, for instance reagent batches, often introduce technical noise in high-dimensional biological data and can lead to erroneous biological conclusions. RUV (Remove Unwanted Variation) methods estimate and correct for unknown, unwanted technical noise;  they are particularly used in the context of gene expression analysis. RUV methods estimate a set of latent variables (unwanted factors) that are associated with the systematic technical noise. To estimate the unwanted factors, RUV methods rely in sets of negative control samples (replicates with low biological variation) and/or negative control genes (genes with constant expression across samples). In the absence of (sufficient) technical replicates and plausible negative control genes, factors of unwanted variation can not be estimated. In the pseudobulk context, we tackled this problem by introducing pseudobulk pseudosamples (PBPS), which are artificial samples generated by pseudobulking cells with similar characteristics, accounting for biological and known technical variables.

Let $\mathcal{C}$ represent the set of all cells in the dataset. The PBPS are created as follows:

1. Identify the biological covariates, i.e., the covariates that are associated with variation we are interested in (e.g., the cell type). We will denote each level of (the combination of) such covariate(s) by $b \in \{1, \ldots, B\}$. Similarly, identify the known sources of unwanted variation, i.e., the covariates associated with the batch effects (e.g., the batch identifiers), and denote the levels by $l \in \{1, \ldots, L\}$. 
    
2. Group cells from single-cell samples that share the same values for the biological covariates. Each group will be called a biological subgroup $b$. These sets are denoted as $\mathcal{C}_b$.
    
3. Within each biological subgroup $b$, compute the average number of cells in single-cell samples, denoted as $\bar{c}_b$.

4. Within each biological subgroup $b$, group cells that share the same value for the known sources of unwanted variation. Denote this set as $\mathcal{C}_{bl}$.

5. Draw $I$ random samples (cells) with replacement of size $\bar{c}_b$ from every set $\mathcal{C}_{bl}$. 

6. Pseudobulk the cells from every random sample $i$, with $i=1,...,I$, to obtain the pseudobulk pseudosample $s'_{bli}$.

At the end, we create a new count matrix $\mb{Y'}_p$ of size $(S + S')\times G$ containing pseudobulk counts from the $S$ original samples and the $S'$ new pseudosamples; note that the number of pseudosamples $S'$ is determined by the number of random samples $I$ and the number of $\mathcal{C}_{bl}$ sets. 

The process is summarised in the `gen_PBPS` function.

# Workflow

To use the `gen_PBPS` function, we required a `SingleCellExperiment` object with annotated cells from multiple samples along with other biological and technical sample-level covariates.
In this case, we use the `dummysce` dataset included in this package to demostrate the process. Among other variables, the metadata of the file has a sample identifier: `ind_cov_batch_cov`, a subject identifier `ind_cov`, a technical variable `Processing_Cohort`, and a biological variable, that happens to be the cell annotation (or cell type) `cg_cov`.

The samples are distributed in two processing cohorts. Two samples were taken from the same subject: 'IGTB195_IGTB195'. There are two cell types in the dataset, T4 and T8, and all samples have at least 394 cells from each cell type.


```{r}

data(dummysce)

samples_info <- colData(dummysce)[,c("ind_cov","ind_cov_batch_cov","cg_cov","sample_cell","Processing_Cohort")]

as.data.frame(samples_info) |>group_by( ind_cov_batch_cov, ind_cov, Processing_Cohort, cg_cov) |> summarise(n=n(),.groups = "drop") |>pivot_wider(names_from=cg_cov,values_from=n)



```



We start by pseudobulking the single cell data based on the sample/cell type identifier `sample_cell`, to later normalise and visualise the data.

```{r}

PBC <- aggregateAcrossCells(dummysce,samples_info[,"sample_cell"]) # Pseudobulk by cell type and sample id
colData(PBC) <- colData(PBC)[,colSums(is.na(colData(PBC)))<nrow(colData(PBC))] # Remove cell level columns with NAs

head(colData(PBC))

```


Then we create a `DGEList` object to filter and normalise the pseudobulk counts, and visualise the data.

```{r}

dge <- edgeR::DGEList(counts = counts(PBC), samples = colData(PBC))


dge_T4 <- dge[rowSums(dge$counts>=10)>=5,dge$samples$cg_cov=="T4"]
dge_T4 <- calcNormFactors(dge_T4,method="upperquartile")
PCA_T4 <- calculatePCA(edgeR::cpm(dge_T4, log = TRUE),ncomponents=2) 

PCA_T4_plot <- data.frame(PCA_T4) |>
  tibble::rownames_to_column("sample_cell") |> # Add the metadata into this data frame; match by sample IDs
  dplyr::inner_join(dge_T4$samples, by = "sample_cell") |>
  ggplot(aes(x = PC1,y = PC2,color= Processing_Cohort)) + geom_point() + 
    #ggtitle("Logcpm plot") +
    labs(color = "Processing cohort", title = "Logcpm PCA plot T4") + 
    theme_minimal()

PCA_T4_plot


```

There is unwanted variation in the dataset associated with the processing cohorts. We will therefore create pseudobulk pseudosamples (PBPS) to use as negative control samples in a method for batch correction such as RUVIII. 

```{r}


PBC_PBPS <-gen_PBPS(counts=dummysce,
        ctype='cg_cov',
        BioVar='cg_cov',
        NVar='Processing_Cohort',
        id_pb = 'sample_cell',
        id_sub = 'ind_cov',
        cell_id = 'cell_id',
        n = 10,
        Seed = NULL)


head(colData(PBC_PBPS[[1]]))

dgePBPS_T4 <- edgeR::DGEList(counts = assay(PBC_PBPS[[1]]) , samples = colData(PBC_PBPS[[1]]))


dgePBPS_T4 <- dgePBPS_T4[rowSums(dgePBPS_T4$counts>=10)>=5,]
dgePBPS_T4 <- calcNormFactors(dgePBPS_T4,method="upperquartile")
PCAPBPS_T4 <- calculatePCA(edgeR::cpm(dgePBPS_T4, log = TRUE),ncomponents=2) 

PCAPBPS_T4_plot <- data.frame(PCAPBPS_T4) |>
  tibble::rownames_to_column("sample_cell") |> # Add the metadata into this data frame; match by sample IDs
  dplyr::inner_join(dgePBPS_T4$samples, by = "sample_cell") |>
  ggplot(aes(x = PC1,y = PC2,color= Processing_Cohort)) + geom_point(aes(shape=as.factor(pbps))) + 
    #ggtitle("Logcpm plot") +
    labs(color = "Processing cohort", title = "Logcpm PCA plot T4", shape= 'PBPS') + 
    theme_minimal()

PCAPBPS_T4_plot

```

